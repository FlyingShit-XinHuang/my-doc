索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。
实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。

缺点：虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。

## 索引的实现原理

详细参考[这篇文章](https://blog.csdn.net/timer_gao/article/details/78013826)

## 索引结构

* Hash索引。只有Memory存储引擎支持Hash索引。由于每个键只对应一个值，而且是散列的方式分布，所以并不支持范围查找和排序等功能。
* B+树索引。Innodb和Myisam引擎的索引类型。查找单条记录的速度比不上Hash索引，但是因为更适合排序等操作，所以其应用场景更多，毕竟实际中不可能只对数据库进行单条记录的操作。

## 索引数据类型选择

* 越小的数据类型越好。使得B+树节点更少，高度更小，从而减少IO次数。
* 尽量避免NULL。含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。应使用特殊值替代NULL。

## 索引使用场景

需要创建索引：
* 频繁作为查询查询条件的字段应该创建索引
* 查询中与其它表关联的字段，外键关系建立索引
* 频繁更新的字段不适合创建索引
* 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度
* 查询中统计或者分组字段

不要建索引：
* 表记录太少
* 经常增删改的表
* 数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据列建立索引。如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果

## 索引失效

* 在索引列上使用函数或运算
* like查询以%开头
* 使用or，可用UNION或IN替换OR (适用于索引列)，以下除外：
  * where 语句里面如果带有or条件，myisam表能用到索引，innodb不行
  * 必须所有的or条件都必须是独立索引
* 未遵循最佳左前缀法则。最佳左前缀法则——如果索引了多列，要遵守最左前缀法则。指的是查询要从索引的最左前列开始并且不跳过索引中的列
* 索引列使用范围条件查询，则复合索引中右侧列失效。如(a,b,c)为索引，则执行select * from a = 1 and b > 2 and c = 3时，c索引列会失效。
* 列类型为字符串，条件中未使用引号。
* <>, !=, is null, is not null无法使用索引。

## 参考资料
* https://www.runoob.com/mysql/mysql-index.html
* https://blog.csdn.net/timer_gao/article/details/78013826
* https://www.cnblogs.com/shijianchuzhenzhi/p/6383117.html
* http://liucw.cn/2018/01/07/mysql/%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90/
